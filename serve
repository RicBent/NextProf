#!/usr/bin/env python3

import sys
import os
import io
import socket
import datetime
import threading
import argparse
import configparser
from http.server import HTTPServer, BaseHTTPRequestHandler
from typing import Optional


SOCKET_TIMEOUT = 0.25


def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(("8.8.8.8", 80))
        ip = s.getsockname()[0]
    finally:
        s.close()
    return ip


def get_config_with_adjusted_host(local_ip: str) -> str:
    parser = configparser.ConfigParser()
    parser.read('config.ini')

    target = 'Network'

    for name in parser.sections():
        if name.lower() == target.lower():
            target = name
            break
    else:
        parser.add_section(target)

    parser[target]["Host"] = local_ip

    with io.StringIO() as buf:
        parser.write(buf)
        return buf.getvalue()


class HttpRequestHandler(BaseHTTPRequestHandler):
    ROUTES = {
        '/sysmodule/nextprof_sys.cia': 'sysmodule/output/nextprof_sys.cia',
        '/sysmodule/code.bin': 'sysmodule/output/nextprof_sys.code.bin',
        '/sysmodule/exheader.bin': 'sysmodule/output/nextprof_sys.exheader.bin',

        '/app/nextprof_app.cia': 'app/output/nextprof_app.cia',
    }

    def send_response_with_content(self, code: int, content: bytes):
        self.send_response(code)
        self.send_header('Content-Length', str(len(content)))
        self.end_headers()
        self.wfile.write(content)

    def do_GET(self):
        if self.path == '/config.ini':
            local_ip = self.server.local_ip
            config = get_config_with_adjusted_host(local_ip)
            self.send_response_with_content(200, config.encode())
            return

        if self.path not in self.ROUTES:
            self.send_error(404)
            return

        file_path = self.ROUTES[self.path]
        try:
            with open(file_path, 'rb') as f:
                content = f.read()
            self.send_response_with_content(200, content)
        except FileNotFoundError:
            self.send_error(404)


def log_udp_loop(stop_event: threading.Event, host: str, port: int, log_file_path: Optional[str] = None):
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind((host, port))
    sock.settimeout(SOCKET_TIMEOUT)

    while not stop_event.is_set():
        try:
            data, addr = sock.recvfrom(2048)

            timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3]
            message = data.decode(errors='replace').rstrip()

            line = f'{timestamp} {addr[0]}:{addr[1]} | {message}'

            print(line)

            if log_file_path:
                with open(log_file_path, 'a') as f:
                    f.write(line + '\n')
        except socket.timeout:
            continue
    
    sock.close()


def record_tcp_loop(stop_event: threading.Event, host: str, port: int):
    server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_sock.bind((host, port))
    server_sock.listen(1)
    server_sock.settimeout(SOCKET_TIMEOUT)

    while not stop_event.is_set():
        try:
            client_sock, addr = server_sock.accept()
            with client_sock:
                record_tcp_client_loop(stop_event, client_sock, addr)
        except socket.timeout:
            continue
    
    server_sock.close()


def record_tcp_client_loop(stop_event: threading.Event, client_sock: socket.socket, addr):
    client_sock.settimeout(SOCKET_TIMEOUT)

    filename = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S") + '.bin'
    filepath = os.path.join('profile', filename)

    print(f'Started recording profiling data from {addr[0]}:{addr[1]} to {filepath}')

    with open(filepath, 'wb') as f:
        while not stop_event.is_set():
            try:
                data = client_sock.recv(2048)
            except socket.timeout:
                continue
            if not data:
                break
            f.write(data)
    
    print(f'Stopped recording profiling data from {addr[0]}:{addr[1]} to {filepath}')
    

def show_qr_codes(host: str, port: int):
    url = f'http://{host}:{port}/app/nextprof_app.cia'
    print(f'App ({url}):')
    os.system(f'qrencode -t ANSI256UTF8 "{url}"')

    url = f'http://{host}:{port}/sysmodule/nextprof_sys.cia'
    print(f'Sysmodule ({url}):')
    os.system(f'qrencode -t ANSI256UTF8 "{url}"')


def main():
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    parser = argparse.ArgumentParser(description='NextProf Host')
    parser.add_argument('-ph', type=int, default=7621, help='Port for HTTP server (default: 7621)')
    parser.add_argument('-pu', type=int, default=7622, help='Port for UDP listener (default: 7622)')
    parser.add_argument('-pt', type=int, default=7623, help='Port for TCP recorder (default: 7623)')
    parser.add_argument('-qr', action='store_true', help='Show QR codes for downloading the app and sysmodule')
    args = parser.parse_args()

    host = '0.0.0.0'
    local_ip = get_local_ip()

    if args.qr:
        show_qr_codes(local_ip, args.ph)

    os.makedirs('log', exist_ok=True)
    log_file_path = os.path.join('log', datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S.txt'))

    os.makedirs('profile', exist_ok=True)

    print(f'HTTP serving on http://{local_ip}:{args.ph}/')
    print(f'UDP listening on {local_ip}:{args.pu}')
    print(f'TCP recording on {local_ip}:{args.pt}')
    print('Press Ctrl+C to stop.\n')

    server = HTTPServer((host, args.ph), HttpRequestHandler)
    server.local_ip = local_ip
    
    stop_event = threading.Event()
    
    http_thread = threading.Thread(target=server.serve_forever, daemon=True)
    http_thread.start()
    
    udp_thread = threading.Thread(target=log_udp_loop, args=(stop_event, host, args.pu, log_file_path), daemon=True)
    udp_thread.start()

    tcp_thread = threading.Thread(target=record_tcp_loop, args=(stop_event, host, args.pt), daemon=True)
    tcp_thread.start()

    try:
        while True:
            threading.Event().wait(1)
    except KeyboardInterrupt:
        print('\nShutting down...')
        stop_event.set()
        server.shutdown()
        udp_thread.join(timeout=SOCKET_TIMEOUT + 1)
        tcp_thread.join(timeout=SOCKET_TIMEOUT + 1)

    sys.exit(0)


if __name__ == '__main__':
    main()
